:source-highlighter: rouge

= 003 Component-Based Architecture

== Context and Problem Statement

We have to provide the most easy way to build applications and services.
These services and applications should be reusable, simple, and understandable for developers.
Also, they should be easy to support and extend.

== Decision

For this purpose, we will use a component-based architecture.
It means that applications and services will be built from components.
It is an easy way to produce clean code and clean architecture.

=== What is component?

Basically component is a piece of code that responsible for one subdomain such as `user account`, `authentication`, etc.
All components contain some packages with business logic and infrastructure code.
Set of packages can be different for each component.
Also, you can add other packages or create infrastructure only components.


.Structure of components
[plantuml, format="svg"]
----
frame "User Account Component" as c {
    component "business" as b #LightGreen {
        folder "entity" as e
        folder "repository" as b.repo
        folder "use_case" as b.uc
        folder "other" as b.o
        note bottom of b.repo
            Interfaces
        end note
        note bottom of b.uc
            Big part of
            business logic
        end note
        note bottom of e
            Business entities
            Not DB entities
        end note
        note bottom of b.o
            examples:
            - value objects
            - services of business layer
            - domain events
            - some type definitions
            - etc
        end note
    }

    component "api-doc" as ad #LightBlue
    component "rest" as r
    component "infrastructure" as i {
        folder "db/repository" as i.rep
        folder "rest" as ir
        folder "other"

        note top of ir
            Implemenation of binding
            between business logic
            and generated rest package
        end note
        note top of i.rep
            Implemenation of binding
            between business logic
            and database
        end note
    }

    note top of r
        Package generated by
        **Argentum Rest Generator**
    end note

    note left of ad
        OpenAPI documentation
    end note

    note bottom of b
        Model of business
    end note

    i.rep --> b.repo
    r --> ad
    ir --> r
    ir --> b.uc
}
----


In this paradigm we should pay maximum attention to the business layer.
Because it is the most important part of the component.
And it is a part of ubiquitous language of the business domain.
Business layer should be independent of other layers.
It helps to implement unit tests quick and easy.


== Consequences +/-

=== Pros (+)

- Makes code and architecture cleaner
- Easy to support
- Easy to write unit tests
- Provides a good way to organize code
- Provides a good way to organize team work
- Helps engineers to understand requirements of stakeholders
- Provides a good way to organize knowledge

=== Cons (-)

- May require more code
- May require additional knowledge

== How to check (Validation)

Basically dependencies can be validated in `Cargo.toml` .
For example, you can use `cargo tree` command
or link:https://crates.io/crates/cargo-depgraph/[cargo-depgraph] tool

[source, bash]
----
cargo tree
----

[source, bash]
----
cargo depgraph | dot -Tpng > graph.png
----


== Links

link:https://crates.io/crates/cargo-depgraph/[cargo-depgraph]

link:https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[The Clean Architecture by Robert C. Martin (Uncle Bob)]

link:https://en.wikipedia.org/wiki/Domain-driven_design[Domain-driven design]

link:https://martinfowler.com/bliki/DomainDrivenDesign.html[Domain-Driven Design by Martin Fowler]

